/* 
===============
２項演算子
===============
*/

// べき乗
console.log(2**4); // => 16
console.log(Math.pow(2,4));

/* 
=====================
単項演算子
=====================
 */

// プラス演算子、マイナス演算子は、文字列の数字を数値に変換できる。変換できない値はNaNとなる。
console.log(+"1"); // => 1
console.log(-"1"); // => -1
console.log("演算子"); // => NaN

// NaNはどの値とも（NaN自身に対しても）一致しない特性があり、Number.isNaNメソッドを使うことでNaNの判定を行えます。
//数値ではないがNumber型の値を表現します。 

// 自分自身とも一致しない
console.log(NaN === NaN); // => false

// Number型である
console.log(typeof NaN); // => "number"

// Number.isNaNでNaNかどうかを判定
console.log(Number.isNaN(NaN)); // => true

// インクリメント演算子は、オペランドの前後どちらに置くかによって評価の順番が異なる
let num1 = 1;
console.log(num1++);// => 1
console.log(num1);// => 2

let num2 = 1;
console.log(++num2);// => 2
console.log(num2);// => 2

// デクリメント演算子も同様に、前後どちらにおくかで評価の順番が異なる
let num3 = 1;
console.log(num3--); // => 1
console.log(num3); // => 0

let num4 = 1;
console.log(--num4); // => 0
console.log(num4); // => 0

/* 
=======================
厳密等価演算子
=======================
厳密等価演算子は、左右の2つのオペランドを比較します。 同じ型で同じ値である場合に、trueを返す。
等価演算子は、暗黙的な変換を行うため、比較するデータ型が異なっても、値が同じであればtrueを返す。
予期しない動作を防ぐためにも、厳密等価演算子を使用したほうがよい。
 */
console.log(1 === "1"); // fase
console.log(1 == "1"); // true

/* 
=======================
厳密不等価演算子
=======================
左右２つのオペラントを比較。 異なる型または異なる値である場合に、trueを返す。
不等価演算子も暗黙的な変換を行うため、比較するデータが異なっても、falseを返す場合がある。
予期しない動作を防ぐためにも、厳密不等価演算子を使用したほうがよい。
 */

console.log(1 !== 2);// true
console.log(1 !== "1");// true
console.log(1 != "1");// false

/* 
===============================================
ビット論理積
===============================================
ビット論理積演算子（&）はビットごとのAND演算した結果を返します。 
AND演算では、オペランドの各ビットがどちらも1の場合は1となり、それ以外の場合は0となります。

以下は、10進数の15と9をAND演算。 
15は、符号付き32ビット整数では0000_0000_0000_0000_0000_0000_0000_1111。 
9は、符号付き32ビット整数では0000_0000_0000_0000_0000_0000_0000_1001。 
これらをAND演算した結果は0000_0000_0000_0000_0000_0000_0000_1001となり、10進数の値である9を返します。
*/
console.log(15     & 9);      // => 9

/* 
====================
ビット論理和
====================
ビット論理和演算子（|）はビットごとのOR演算した結果を返す。 
OR演算では、オペランドの各ビットがどちらか片方でも1の場合は1となり、両方とも0の場合は0となります。
 */
console.log(15     | 9);      // => 15

/* 
================================
ビット排他的論理和
================================
ビット排他的論理和演算子（^）はビットごとのXOR演算した結果を返す。 
XOR演算では、オペランドのビットが異なるなら1、両方とも同じなら0。
 */

// 以下は、10進数の15と9をAND演算。 
// 15は、符号付き32ビット整数では0000_0000_0000_0000_0000_0000_0000_1111。 
// 9は、符号付き32ビット整数では0000_0000_0000_0000_0000_0000_0000_1001。 

console.log(15     ^ 9);      // => 6

/* 
========================
ビット否定
========================
単項演算子の否定演算子（~）はオペランドの各ビットを反転した値を返します。
~xのようにxをビット否定演算子で演算した結果は、-(x + 1)となります。
 */

console.log(~15); // => -16
