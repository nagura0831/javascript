/* 
==========================================
constについて
==========================================
constは、再代入できない変数の宣言とその変数が参照する値（初期値）を定義できます。
一般的に変数への再代入は「変数の値は最初に定義した値と常に同じである」という参照透過性と呼ばれるルールを壊すため、
バグを発生させやすい要因として知られている。
そのため、変数に対して値を再代入する必要がない場合は、constキーワードで変数宣言することを推奨
*/

/*
次のように、constキーワードに続いて変数名を書き、代入演算子（=）の右辺に変数の初期値を書いて変数を定義できます。
const 変数名 = 値;
*/

const test = "test";

//まとめて定義したい場合は、,で区切る
const test2 = "test2",
      test3 = "test3";

/* 
constは再代入できないため、すでに定義した変数に対して、新たな値を代入しようとするとエラーになる
以下はその例 
*/

const test = hoge; //  => Cannot redeclare block-scoped variable 'test'

/* 
==========================================
letについて
==========================================
変数に値を再代入したいケースとして、ループなどの反復処理の途中で特定の変数が参照する値を変化させたい場合がある。
そのような場合には、変数への再代入が可能なletを利用
 */

// 次のコードでは、bookTitleという変数を宣言し、値が"JavaScript Primer"という文字列であることを定義しています。
let booktitle = "JavaScript Primer";

// constと違って、以下のように値を設定せずとも変数を宣言可能。この場合、デフォルト値として、undefinedが代入される。
let title; // => `title`は自動的に`undefined`という値になる

// letで宣言された`title`は、以下のように代入演算子`=`をつかって、代入可能。
title = "Javascript basic"

/* 
==========================================
varについて
========================================== 
varでは、値の再代入が可能な変数を宣言できます。 varの使い方はletとほとんど同じです。
*/

var text = "varについて"

var number
number = 1;

/* 
==========================================
varの問題点
==========================================
varには同じ名前の変数を再定義できてしまう問題がある。
letやconstでは、同じ名前の変数を再定義しようとすると、次のような構文エラーが発生します
そのため、間違えて変数を二重に定義してしまうというミスを防ぐことができます。
 */

// "x"という変数名で変数を定義する
let x;

// 同じ名前の変数"x"を定義するとSyntaxErrorとなる
let x; // => SyntaxError: redeclaration of let x

// 一方、varは同じ名前の変数を再定義できる。 これは意図せずに同じ変数名で定義してもエラーとならずに、値を上書きしてしまう。

// "x"という変数を定義する
var x = 1;

// 同じ名前の変数"x"を定義できる
var x = 2; //  => 変数xは2となる
